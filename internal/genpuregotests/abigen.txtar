Templates for ABI test generation.
File names in this archive specify the output paths relative to the repository root.

-- testdata/abitest/abitest_gen_test.c --
// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2025 The Ebitengine Authors
// Code generated by internal/genpuregotests; DO NOT EDIT.
//
// ABI Test C Functions
// These functions return string representations of their arguments to verify
// correct ABI implementation across different platforms.

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

{{range $testName, $specs := .abitest}}{{range $specs}}{{$test := expandSpec .}}
char* {{$test.Name}}({{range $i, $p := $test.Params}}{{if $i}}, {{end}}{{$p.Type}} {{$p.Name}}{{end}}) {
    char* result = malloc(1024);
    snprintf(result, 1024, "{{range $i, $p := $test.Params}}{{if $i}}:{{end}}%{{$p.Format}}{{end}}"{{range $test.Params}}, ({{.FormatCast}}){{.Name}}{{end}});
    return result;
}

{{end}}{{end}}

-- abitest_gen_test.go --
// Copyright 2025 The Ebitengine Authors
// SPDX-License-Identifier: Apache-2.0
// Code generated by internal/genpuregotests; DO NOT EDIT.
//
// ABI Test Suite
// These tests verify correct ABI implementation for Go â†’ C library calls.
// They test register allocation, stack packing, and type handling per platform calling conventions.

package purego_test

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/ebitengine/purego"
	"github.com/ebitengine/purego/internal/load"
)

func loadTestLib(t *testing.T) uintptr {
	t.Helper()
	libFileName := filepath.Join(t.TempDir(), "libabitestgenerated.so")
	if err := buildSharedLib("CC", libFileName, filepath.Join("testdata", "abitest", "abitest_gen_test.c")); err != nil {
		t.Fatal(err)
	}
	t.Cleanup(func() {
		os.Remove(libFileName)
	})
	lib, err := load.OpenLibrary(libFileName)
	if err != nil {
		t.Fatalf("Failed to open library %q: %v", libFileName, err)
	}
	t.Cleanup(func() {
		if err := load.CloseLibrary(lib); err != nil {
			t.Errorf("Failed to close library: %v", err)
		}
	})
	return lib
}

{{range $testName, $specs := .abitest}}
func {{$testName}}(t *testing.T) {
	{{- range $specs}}{{$test := expandSpec .}}
	t.Run("{{$test.Name}}", func(t *testing.T) {
		defer func() { if r := recover(); r != nil { t.Errorf("{{$test.Name}} panicked: %v", r) } }()
		lib := loadTestLib(t)
		var fn func({{range $i, $p := $test.Params}}{{if $i}}, {{end}}{{$p.GoType}}{{end}}) string
		purego.RegisterLibFunc(&fn, lib, "{{$test.Name}}")

		result := fn({{range $i, $p := $test.Params}}{{if $i}}, {{end}}{{$p.TestValue $i}}{{end}})
		const want = "{{range $i, $p := $test.Params}}{{if $i}}:{{end}}{{$p.ExpectedOutput $i}}{{end}}"
		if result != want {
			t.Errorf("\ngot:  %q\nwant: %q", result, want)
		}
	})
	{{end}}
}

{{end}}

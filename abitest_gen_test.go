// Copyright 2025 The Ebitengine Authors
// SPDX-License-Identifier: Apache-2.0
// Code generated by internal/genpuregotests; DO NOT EDIT.
//
// ABI Test Suite
// These tests verify correct ABI implementation for Go â†’ C library calls.
// They test register allocation, stack packing, and type handling per platform calling conventions.

package purego_test

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/ebitengine/purego"
	"github.com/ebitengine/purego/internal/load"
)

func loadTestLib(t *testing.T) uintptr {
	t.Helper()
	libFileName := filepath.Join(t.TempDir(), "libabitestgenerated.so")
	if err := buildSharedLib("CC", libFileName, filepath.Join("testdata", "abitest", "abitest_gen_test.c")); err != nil {
		t.Fatal(err)
	}
	t.Cleanup(func() {
		os.Remove(libFileName)
	})
	lib, err := load.OpenLibrary(libFileName)
	if err != nil {
		t.Fatalf("Failed to open library %q: %v", libFileName, err)
	}
	t.Cleanup(func() {
		if err := load.CloseLibrary(lib); err != nil {
			t.Errorf("Failed to close library: %v", err)
		}
	})
	return lib
}


func TestABIGenerated(t *testing.T) {
	t.Run("test_11_int32", func(t *testing.T) {
		defer func() { if r := recover(); r != nil { t.Errorf("test_11_int32 panicked: %v", r) } }()
		lib := loadTestLib(t)
		var fn func(int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32) string
		purego.RegisterLibFunc(&fn, lib, "test_11_int32")

		result := fn(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
		const want = "1:2:3:4:5:6:7:8:9:10:11"
		if result != want {
			t.Errorf("\ngot:  %q\nwant: %q", result, want)
		}
	})
	
	t.Run("test_12_int32", func(t *testing.T) {
		defer func() { if r := recover(); r != nil { t.Errorf("test_12_int32 panicked: %v", r) } }()
		lib := loadTestLib(t)
		var fn func(int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32) string
		purego.RegisterLibFunc(&fn, lib, "test_12_int32")

		result := fn(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)
		const want = "1:2:3:4:5:6:7:8:9:10:11:12"
		if result != want {
			t.Errorf("\ngot:  %q\nwant: %q", result, want)
		}
	})
	
	t.Run("test_mixed_8i32_1f32_1i32", func(t *testing.T) {
		defer func() { if r := recover(); r != nil { t.Errorf("test_mixed_8i32_1f32_1i32 panicked: %v", r) } }()
		lib := loadTestLib(t)
		var fn func(int32, int32, int32, int32, int32, int32, int32, int32, float32, int32) string
		purego.RegisterLibFunc(&fn, lib, "test_mixed_8i32_1f32_1i32")

		result := fn(1, 2, 3, 4, 5, 6, 7, 8, float32(9), 10)
		const want = "1:2:3:4:5:6:7:8:9.000000:10"
		if result != want {
			t.Errorf("\ngot:  %q\nwant: %q", result, want)
		}
	})
	
	t.Run("test_8i32_3strings", func(t *testing.T) {
		defer func() { if r := recover(); r != nil { t.Errorf("test_8i32_3strings panicked: %v", r) } }()
		lib := loadTestLib(t)
		var fn func(int32, int32, int32, int32, int32, int32, int32, int32, string, string, string) string
		purego.RegisterLibFunc(&fn, lib, "test_8i32_3strings")

		result := fn(1, 2, 3, 4, 5, 6, 7, 8, "grault", "garply", "waldo")
		const want = "1:2:3:4:5:6:7:8:grault:garply:waldo"
		if result != want {
			t.Errorf("\ngot:  %q\nwant: %q", result, want)
		}
	})
	
	t.Run("test_mixed_stack_strings", func(t *testing.T) {
		defer func() { if r := recover(); r != nil { t.Errorf("test_mixed_stack_strings panicked: %v", r) } }()
		lib := loadTestLib(t)
		var fn func(int32, int32, int32, int32, int32, int32, int32, int32, string, int32, string) string
		purego.RegisterLibFunc(&fn, lib, "test_mixed_stack_strings")

		result := fn(1, 2, 3, 4, 5, 6, 7, 8, "grault", 10, "waldo")
		const want = "1:2:3:4:5:6:7:8:grault:10:waldo"
		if result != want {
			t.Errorf("\ngot:  %q\nwant: %q", result, want)
		}
	})
	
	t.Run("test_string_only_10", func(t *testing.T) {
		defer func() { if r := recover(); r != nil { t.Errorf("test_string_only_10 panicked: %v", r) } }()
		lib := loadTestLib(t)
		var fn func(string, string, string, string, string, string, string, string, string, string) string
		purego.RegisterLibFunc(&fn, lib, "test_string_only_10")

		result := fn("hello", "world", "foo", "bar", "baz", "qux", "quux", "corge", "grault", "garply")
		const want = "hello:world:foo:bar:baz:qux:quux:corge:grault:garply"
		if result != want {
			t.Errorf("\ngot:  %q\nwant: %q", result, want)
		}
	})
	
	t.Run("test_1i32_10strings", func(t *testing.T) {
		defer func() { if r := recover(); r != nil { t.Errorf("test_1i32_10strings panicked: %v", r) } }()
		lib := loadTestLib(t)
		var fn func(int32, string, string, string, string, string, string, string, string, string, string) string
		purego.RegisterLibFunc(&fn, lib, "test_1i32_10strings")

		result := fn(1, "world", "foo", "bar", "baz", "qux", "quux", "corge", "grault", "garply", "waldo")
		const want = "1:world:foo:bar:baz:qux:quux:corge:grault:garply:waldo"
		if result != want {
			t.Errorf("\ngot:  %q\nwant: %q", result, want)
		}
	})
	
	t.Run("test_mixed_bool_string", func(t *testing.T) {
		defer func() { if r := recover(); r != nil { t.Errorf("test_mixed_bool_string panicked: %v", r) } }()
		lib := loadTestLib(t)
		var fn func(bool, bool, bool, bool, bool, bool, bool, bool, string, string, string) string
		purego.RegisterLibFunc(&fn, lib, "test_mixed_bool_string")

		result := fn(false, true, false, true, false, true, false, true, "grault", "garply", "waldo")
		const want = "0:1:0:1:0:1:0:1:grault:garply:waldo"
		if result != want {
			t.Errorf("\ngot:  %q\nwant: %q", result, want)
		}
	})
	
	t.Run("test_float_then_int", func(t *testing.T) {
		defer func() { if r := recover(); r != nil { t.Errorf("test_float_then_int panicked: %v", r) } }()
		lib := loadTestLib(t)
		var fn func(float32, float32, float32, float32, float32, float32, float32, float32, int32, int32, int32, int32, int32, int32, int32, int32) string
		purego.RegisterLibFunc(&fn, lib, "test_float_then_int")

		result := fn(float32(1), float32(2), float32(3), float32(4), float32(5), float32(6), float32(7), float32(8), 9, 10, 11, 12, 13, 14, 15, 16)
		const want = "1.000000:2.000000:3.000000:4.000000:5.000000:6.000000:7.000000:8.000000:9:10:11:12:13:14:15:16"
		if result != want {
			t.Errorf("\ngot:  %q\nwant: %q", result, want)
		}
	})
	
	t.Run("test_mixed_f32_f64_mix", func(t *testing.T) {
		defer func() { if r := recover(); r != nil { t.Errorf("test_mixed_f32_f64_mix panicked: %v", r) } }()
		lib := loadTestLib(t)
		var fn func(float32, float32, float32, float32, float64, float64, float64, float64, float32, float32) string
		purego.RegisterLibFunc(&fn, lib, "test_mixed_f32_f64_mix")

		result := fn(float32(1), float32(2), float32(3), float32(4), float64(5), float64(6), float64(7), float64(8), float32(9), float32(10))
		const want = "1.000000:2.000000:3.000000:4.000000:5.000000:6.000000:7.000000:8.000000:9.000000:10.000000"
		if result != want {
			t.Errorf("\ngot:  %q\nwant: %q", result, want)
		}
	})
	
}


